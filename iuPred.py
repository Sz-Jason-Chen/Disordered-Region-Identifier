import numpy as np
import pandas as pd
import statistics
import matplotlib.pyplot as plt
import re
import string
import math

from scipy.interpolate import make_interp_spline
# amino acid interaction energy matrix
P=[ [-1.65, -2.83, 1.16, 1.80, -3.73, -0.41, 1.90, -3.69, 0.49, -3.01, -2.08, 0.66, 1.54, 1.20, 0.98, -0.08, 0.46, -2.31, 0.32,-4.62],
    [-2.83, -39.58, -0.82, -0.53, -3.07, -2.96, -4.98, 0.34, -1.38, -2.15, 1.43, -4.18, -2.13, -2.91, -0.41, -2.33, -1.84, -0.16, 4.26, -4.46],
    [1.16, -0.82, 0.84, 1.97, -0.92, 0.88, -1.07, 0.68, -1.93, 0.23, 0.61, 0.32, 3.31, 2.67, -2.02, 0.91, -0.65, 0.94, -0.71, 0.90],
    [1.80, -0.53, 1.97, 1.45, 0.94, 1.31, 0.61, 1.30, -2.51, 1.14, 2.53, 0.20, 1.44, 0.10, -3.13, 0.81, 1.54, 0.12, -1.07, 1.29],
    [-3.73, -3.07, -0.92, 0.94, -11.25, 0.35, -3.57, -5.88, -0.82, -8.59, -5.34, 0.73, 0.32, 0.77, -0.40, -2.22, 0.11, -7.05, -7.09, -8.80],
    [-0.41, -2.96, 0.88, 1.31, 0.35, -0.20, 1.09, -0.65, -0.16, -0.55, -0.52, -0.32, 2.25, 1.11, 0.84, 0.71, 0.59, -0.38, 1.69, -1.90],
    [1.90, -4.98, -1.07, 0.61, -3.57, 1.09, 1.97, -0.71, 2.89, -0.86, -0.75, 1.84, 0.35, 2.64, 2.05, 0.82, -0.01, 0.27, -7.58, -3.20],
    [-3.69, 0.34, 0.68, 1.30, -5.88, -0.65, -0.71, -6.74, -0.01, -9.01, -3.62, -0.07, 0.12, -0.18, 0.19, -0.15, 0.63, -6.54, -3.78, -5.26],
    [0.49, -1.38, -1.93, -2.51, -0.82, -0.16, 2.89, -0.01, 1.24, 0.49, 1.61, 1.12, 0.51, 0.43, 2.34, 0.19, -1.11, 0.19, 0.02, -1.19],
    [-3.01, -2.15, 0.23, 1.14, -8.59, -0.55, -0.86, -9.01, 0.49, -6.37, -2.88, 0.97, 1.81, -0.58, -0.60, -0.41, 0.72, -5.43, -8.31,-4.90],
    [-2.08, 1.43, 0.61, 2.53, -5.34, -0.52, -0.75, -3.62, 1.61, -2.88, -6.49, 0.21, 0.75, 1.90, 2.09, 1.39, 0.63, -2.59, -6.88, -9.73],
    [0.66, -4.18, 0.32, 0.20, 0.73, -0.32, 1.84, -0.07, 1.12, 0.97, 0.21, 0.61, 1.15, 1.28, 1.08, 0.29, 0.46, 0.93, -0.74, 0.93],
    [1.54, -2.13, 3.31, 1.44, 0.32, 2.25, 0.35, 0.12, 0.51, 1.81, 0.75, 1.15, -0.42, 2.97, 1.06, 1.12, 1.65, 0.38, -2.06, -2.09],
    [1.20, -2.91, 2.67, 0.10, 0.77, 1.11, 2.64, -0.18, 0.43, -0.58, 1.90, 1.28, 2.97, -1.54, 0.91, 0.85, -0.07, -1.91, -0.76, 0.01],
    [0.98, -0.41, -2.02, -3.13, -0.40, 0.84, 2.05, 0.19, 2.34, -0.60, 2.09, 1.08, 1.06, 0.91, 0.21, 0.95, 0.98, 0.08, -5.89, 0.36],
    [-0.08, -2.33, 0.91, 0.81, -2.22, 0.71, 0.82, -0.15, 0.19, -0.41, 1.39, 0.29, 1.12, 0.85, 0.95, -0.48, -0.06, 0.13, -3.03, -0.82],
    [0.46, -1.84, -0.65, 1.54, 0.11, 0.59, -0.01, 0.63, -1.11, 0.72, 0.63, 0.46, 1.65, -0.07, 0.98, -0.06, -0.96, 1.14, -0.65, -0.37],
    [-2.31, -0.16, 0.94, 0.12, -7.05, -0.38, 0.27, -6.54, 0.19, -5.43, -2.59, 0.93, 0.38, -1.91, 0.08, 0.13, 1.14, -4.82, -2.13, -3.59],
    [0.32, 4.26, -0.71, -1.07, -7.09, 1.69, -7.58, -3.78, 0.02, -8.31, -6.88, -0.74, -2.06, -0.76, -5.89, -3.03, -0.65, -2.13, -1.73, -12.39],
    [-4.62, -4.46, 0.90, 1.29, -8.80, -1.90, -3.20, -5.26, -1.19, -4.90, -9.73, 0.93, -2.09, 0.01, 0.36,-0.82,-0.37,-3.59,-12.39,-2.68]]
amino_acids = {
    "ALA": "A",
    "ARG": "R",
    "ASN": "N",
    "ASP": "D",
    "CYS": "C",
    "GLU": "E",
    "GLN": "Q",
    "GLY": "G",
    "HIS": "H",
    "ILE": "I",
    "LEU": "L",
    "LYS": "K",
    "MET": "M",
    "PHE": "F",
    "PRO": "P",
    "SER": "S",
    "THR": "T",
    "TRP": "W",
    "TYR": "Y",
    "VAL": "V",
}
aa_name=["A", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "W", "Y"]
def get_key_from_value(dictionary, search_value):
    for key, value in dictionary.items():
        if value == search_value:
            return key
    return None
# dt=pd.read_csv("C:/Users/13423/OneDrive/python data/BMI3/pdb1h4l.ent",sep="\t")
def extract_resolution(file_path):
    with open(file_path, 'r') as file:
        for line in file:
            words = line.split()
            if line.startswith('REMARK') and len(words)>2:
                
                word = words[2]
                
                if "RESOLUTION" in word:

                    res = words[3]
                
                
                    return res
resolution=extract_resolution("C:/Users/13423/OneDrive/python data/BMI3/pdb1h4l.ent")

# 打开文件
def extract_atom_amino_acid_coordinates(file_path):
    atom_amino_acid_coordinates = []
    with open(file_path, 'r') as file:
        for line in file:
            if line.startswith('ATOM'):
                words = line.split()
                #extract the atom coordinate, amino acid and amino acid coordinate
                atom_coordinate = words[1]
                amino_acid = words[3]
                chain_id=words[4]
                amino_acid_coordinate = words[5]
                atom_amino_acid_coordinates.append((atom_coordinate, amino_acid,chain_id, amino_acid_coordinate))
    return atom_amino_acid_coordinates

file_path = "C:/Users/13423/OneDrive/python data/BMI3/pdb1h4l.ent"
coordinates = extract_atom_amino_acid_coordinates(file_path)
coor_df=pd.DataFrame(coordinates)


punctuation = string.punctuation
# extract real chains
def extract_chain(file_path):
    with open(file_path, 'r') as file:
        for line in file:
            if line.startswith('COMPND'):
                words = line.split()
                word = words[2]
                
                if "CHAIN" in word:

                    matches = words[3:]
                #extract the atom coordinate, amino acid and amino acid coordinate
                    if len(matches) > 0:
                        chain_list=[]
                        
                        for item in matches:
                            cleaned_item = item.strip().translate(str.maketrans("", "", punctuation))
                            chain_list.append(cleaned_item)
                        
                
                    return chain_list
selected_chain=extract_chain("C:/Users/13423/OneDrive/python data/BMI3/pdb1h4l.ent")

# extract amino acid sequence
def extract_aa_seq_coordinates(file_path,selected_chain):
    res={}
    for chain in selected_chain:
        res[chain]=[]
    
    with open(file_path, 'r') as file:
        for line in file:
            if line.startswith('SEQRES'):
                words = line.split()
                chain_name = words[2]
                if chain_name in selected_chain:
                #extract the atom coordinate, amino acid and amino acid coordinate
                    res[chain_name].extend(words[4:17])
                
    return res
file_path = "C:/Users/13423/OneDrive/python data/BMI3/pdb1h4l.ent"
seq_res = extract_aa_seq_coordinates(file_path,selected_chain)
#for coord in coordinates:
# print(f"atom_coordinate: {coord[0]}, amino_acid: {coord[1]}, chain_id: {coord[2]},amino_acid_coordinate: {coord[3]}") 
seq_df=pd.DataFrame(seq_res)

# IUPred 
IUP_res={}
for col in seq_df.columns:
    scores=[]
    """ for i in range(seq_df.shape[0]):
        score=0
        if i<49 and (seq_df.shape[0]-i)>=49:
            seq=list(seq_df[col])[0:i]
            seq.extend(list(seq_df[col])[i+1:100])
            
        elif i>=49 and (seq_df.shape[0]-i)>=49:
            seq=list(seq_df[col])[i-50:i]
            seq.extend(list(seq_df[col])[i+1:i+50])
        elif i<49 and (seq_df.shape[0]-i)<49:
            seq=list(seq_df[col])[0:i]
            seq.extend(list(seq_df[col])[i+1:seq_df.shape[0]])
        else:
            seq=list(seq_df[col])[seq_df.shape[0]-100:i]
            seq.extend(list(seq_df[col])[i+1:seq_df.shape[0]])
        ref_aa=amino_acids[seq_df[col][i]]
        ref_position=aa_name.index(ref_aa)
        aa_counts = {}
        aa_counts[get_key_from_value(amino_acids,ref_aa)]=1
        for aa in seq:
            count = seq.count(aa)
            if aa==get_key_from_value(amino_acids,ref_aa):
                aa_counts[aa] += count
            else:
            
                aa_counts[aa] = count """
    for i in range(seq_df.shape[0]):
        score=0
        if i<49 and (seq_df.shape[0]-i)>=49:
            seq=list(seq_df[col])[0:i]
            seq.extend(list(seq_df[col])[i+1:i+50])
            
        elif i>=49 and (seq_df.shape[0]-i)>=49:
            seq=list(seq_df[col])[i-50:i]
            seq.extend(list(seq_df[col])[i+1:i+50])
        elif i<49 and (seq_df.shape[0]-i)<49:
            seq=list(seq_df[col])[0:i]
            seq.extend(list(seq_df[col])[i+1:seq_df.shape[0]])
        else:
            seq=list(seq_df[col])[i-50:i]
            seq.extend(list(seq_df[col])[i+1:seq_df.shape[0]])
        ref_aa=amino_acids[seq_df[col][i]]
        ref_position=aa_name.index(ref_aa)
        aa_counts = {}
        aa_counts[get_key_from_value(amino_acids,ref_aa)]=1
        for aa in seq:
            count = seq.count(aa)
            if aa==get_key_from_value(amino_acids,ref_aa):
                aa_counts[aa] += count
            else:
            
                aa_counts[aa] = count
    
    
    
        
        
        for k in aa_counts.keys():
            test_position=aa_name.index(amino_acids[k])
            score=score+round(aa_counts[k]*P[ref_position][test_position],2)
        score=score/len(seq)
        scores.append(score)
        e_scores=[]
        for num in scores:
            result = num
            #math.exp(num)
            e_scores.append(result)
    e_scores=(e_scores - np.min(e_scores)) / (np.max(e_scores) - np.min(e_scores))
    IUP_res[col]=e_scores


x_smooth = np.linspace(1, len(IUP_res["A"])+1, 30)
y1_smooth = make_interp_spline(range(1,len(IUP_res["A"])+1), IUP_res["A"])(x_smooth)
    # plot curve 1
plt.plot(x_smooth, y1_smooth, label='Pred Score')
""" 

plt.plot(range(1,len(IUP_res["A"])+1),IUP_res["A"]) """


IUP_ref=np.array([  0.3857043984381414,
        0.4005870001358058,
        0.41223844394366965,
        0.4177140125007405,
        0.42332580462624175,
        0.42739486386384623,
        0.42850752335300235,
        0.4256227916813634,
        0.42307857575622504,
        0.42451085677358075,
        0.419369715384692,
        0.4144600044773154,
        0.4182381427533606,
        0.4228838619594073,
        0.4230315342474802,
        0.4184751899544604,
        0.4178929257435469,
        0.413281267754772,
        0.410542129007962,
        0.3951889185965443,
        0.38407865264279445,
        0.37804462695696117,
        0.37380548254364876,
        0.36908966561354173,
        0.36676747959564704,
        0.36805212198142345,
        0.3808764210010223,
        0.38247994328716967,
        0.38643734536831587,
        0.3885455548289473,
        0.3900772549237922,
        0.3808116250979439,
        0.3622171382605502,
        0.3457590652122029,
        0.3315775333025297,
        0.3127769243936253,
        0.29289438486526925,
        0.2651654205365749,
        0.25088955032388044,
        0.2389484963735079,
        0.2312202707395263,
        0.23126218970034615,
        0.23326186701435395,
        0.24593657053142964,
        0.2587815849810254,
        0.26541873255603665,
        0.272318960142866,
        0.2811614658956715,
        0.28818672524913824,
        0.28596343228976356,
        0.28001863050529646,
        0.27289906045655893,
        0.2635991473447915,
        0.2671366358068101,
        0.25735178169566003,
        0.24370572848175184,
        0.2356667968223362,
        0.2312669753834758,
        0.2208285280554738,
        0.21632383230352276,
        0.2137933154480057,
        0.2139144817158565,
        0.2131453948050023,
        0.20781256727041905,
        0.18928118533198418,
        0.17893463160480064,
        0.1667363133892685,
        0.15356521628823014,
        0.1434229709373498,
        0.13778764701376242,
        0.12917764398034515,
        0.11916417026047982,
        0.10177518769207426,
        0.08615324400281658,
        0.07506202553676869,
        0.0674624153397192,
        0.0590341844073579,
        0.05349010081045117,
        0.04790858438387881,
        0.0421920070609002,
        0.03661187436499363,
        0.03172192127598629,
        0.028028700663791442,
        0.02707215524531148,
        0.02705468382590894,
        0.027017134746500554,
        0.027373288946105523,
        0.028276282817582498,
        0.028540520101320115,
        0.029537654607619434,
        0.029547295976757256,
        0.029358317094100216,
        0.0296700390904822,
        0.029633480759517623,
        0.03226865493617183,
        0.033796445763685456,
        0.03649941660768191,
        0.04048972463713967,
        0.04433615069493659,
        0.04972603517475138,
        0.05464065213021165,
        0.06215164748630013,
        0.07260644963712945,
        0.08371475467175223,
        0.0941963614392559,
        0.0973828346084653,
        0.09373391906978476,
        0.08785205415279103,
        0.08059895868483562,
        0.07383542531058895,
        0.06543613199474846,
        0.05810085043294479,
        0.05116060443188423,
        0.045168512854246765,
        0.0401670541535305,
        0.03611986675989102,
        0.03250519216169326,
        0.03414817453670572,
        0.03655190907510301,
        0.03959866184319596,
        0.04301070982343222,
        0.047105444286035386,
        0.05307192080015186,
        0.05809095044245277,
        0.06196877673137629,
        0.06636441324611532,
        0.0711535915473942,
        0.07701941693251065,
        0.07645478100279307,
        0.07425295156170693,
        0.0721707336176136,
        0.06956339234975341,
        0.06546143732208186,
        0.06051985084138381,
        0.05708507866746111,
        0.05437213155530125,
        0.050977332135391636,
        0.047476048181729055,
        0.04423054772591356,
        0.04121339477327287,
        0.03911153017464595,
        0.03636805642333522,
        0.03424979000789184,
        0.033420729982143314,
        0.0323654577145135,
        0.03212793799301381,
        0.03076770008789627,
        0.030318310960937955,
        0.03038338332743613,
        0.029614160889278922,
        0.029299432728138952,
        0.02884175998758734,
        0.02872386655595745,
        0.029694310383559925,
        0.030125310946528212,
        0.03266986339760373,
        0.03444708150923379,
        0.0386794843427939,
        0.043766122598691386,
        0.049864602971012875,
        0.059285572193284806,
        0.06884630248928196,
        0.08098232236422374,
        0.09721493080349869,
        0.11125161657166588,
        0.1276025873258677,
        0.13148606920844103,
        0.13584195788338493,
        0.13308138220395624,
        0.12581499432493864,
        0.11818457657051637,
        0.10741870063147993,
        0.09780660038941348,
        0.08954495531161011,
        0.08074698531885442,
        0.07689636926230185,
        0.07496085483672447,
        0.07668979946728978,
        0.08046124558489455,
        0.0880789165213101,
        0.09853071938491124,
        0.11135018258135133,
        0.12923704057945845,
        0.15623012418918436,
        0.1853404649451937,
        0.21344287095509043,
        0.22621455259550585,
        0.23825769686899906,
        0.2519941112177606,
        0.2586972499423735,
        0.2592124231095415,
        0.2614375313161976,
        0.2620257072661478,
        0.2605180265228428,
        0.2538509637095057,
        0.24401044894194668,
        0.2400817142082142,
        0.24762130452175005,
        0.25750790187213574,
        0.2689481243621342,
        0.2851218788566132,
        0.30487291580498277,
        0.31602641728319475,
        0.3236975365395339,
        0.3337176313355035,
        0.34843099828873325,
        0.3676217959689905,
        0.3875580423990726,
        0.40726691086035405,
        0.4219636050138608,
        0.43149016764998677,
        0.43017384433281264,
        0.4311013889712037,
        0.4236353819107538,
        0.41227149230370325,
        0.40294547283899707,
        0.39860517775619453,
        0.3955238592216418,
        0.4002939444483385,
        0.40954549957113545,
        0.41684541162710764,
        0.4216908402766114,
        0.42136485089259956,
        0.41772823955974014,
        0.41652002899528423,
        0.4156193700579058,
        0.41567295058062176,
        0.4174248700775397,
        0.41763486244067216,
        0.4126129117522207,
        0.4046290436918788,
        0.3932134558073684,
        0.38054774480750453,
        0.37426151156596854,
        0.36827116290218975,
        0.36510615292120585,
        0.36401113766725474,
        0.3572960077134348,
        0.348707686450935,
        0.3456132355826828,
        0.34197135951696606,
        0.3433313865530155,
        0.35185926761621555,
        0.3634426785827394,
        0.36789564519835494,
        0.3723430425810527,
        0.37511626586229685,
        0.37850689715135116,
        0.3901212710401587,
        0.4036262665904646,
        0.410381866017512,
        0.4134183462293207,
        0.4083236084205407,
        0.39833746670451853,
        0.38627623128604466,
        0.3759095987728961,
        0.3586311601912579,
        0.3432560743062878,
        0.33046682250357706,
        0.31325740151990933,
        0.2950546898928152,
        0.2828745434856479,
        0.2834827456761117,
        0.29490348107082187,
        0.30754220941210236,
        0.3200103198385302,
        0.3414486733978117,
        0.3774824676652429,
        0.4120862138854662,
        0.43010828145574825,
        0.4110217158414898,
        0.39460454565481157,
        0.37873098129253835,
        0.3710900682684587,
        0.37276292444563647,
        0.3798002999552871,
        0.3856854212284382,
        0.4015168757391561,
        0.4271181877386107,
        0.4244633655475079,
        0.41250818208267837,
        0.41105258270693107,
        0.40781859343648197,
        0.4025212861748578,
        0.3972750331861019,
        0.39949470863190173,
        0.41756970314542097,
        0.42136672711844864,
        0.429789073626372,
        0.4229726114357858,
        0.41757238189780754,
        0.4084953559558068])
IUP_ref=(IUP_ref - np.min(IUP_ref)) / (np.max(IUP_ref) - np.min(IUP_ref))
print(np.min(IUP_ref),np.max(IUP_ref))
print(IUP_ref)
y2_smooth = make_interp_spline(range(1,len(IUP_ref)+1), IUP_ref)(x_smooth)
plt.plot(x_smooth, y2_smooth, label='Ref Score')
plt.show()

""" 
seq_len=pd.DataFrame(IUP_res).shape[0]

# FIND GAPS
def find_coordinate_gaps(coor_df):
    res={}
    for chain in selected_chain:
        gaps=[0]*seq_len
        data=coor_df[coor_df[2]==chain]
        
        for i in range(1,data.shape[0]):
            data[i-1][3]=int(data[i-1][3])
            data[i][3]=int(data[i][3])
            print(type(data[i][3]))
            if data[i-1][3]-data[i][3]>1:
                for a in range(data[i-1][3],data[i][3]-1):
                    gaps[a]+=1
        if data[0][3]>1:
            for a in range(0,data[0][3]-1):
                gaps[a]+=1
        if data[data.shape[0]-1][3]<seq_len:
            
            for a in range(data[data.shape[0]-1][3]-1,seq_len):
                gaps[a]+=1
        res[chain]=gaps
    return res

# Find and print any potential gaps
gaps = find_coordinate_gaps(coor_df)
print(gaps) """